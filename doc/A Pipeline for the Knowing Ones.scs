// Solid Command Sequence
// a prototype script language
// idea: simple and explicit
// the language does not have to be turing-complete, and may not use control structures if it does not need them

// Every function accepts either a specialisation of the type or a generalisation of the type.
// that is, you can implicitly cast up or down, but not both in one statement.
// Casting down (to a specialisation) may cause runtime errors, and should be avoided.
// Any non-static function of `T` can be applied to T[]. 
// This applies the function to each element in parallel, collecting the results as an array

// A `native` function describes a cdecl dll function
// any value is _always_ effectively copied
// a closing bracket ends a function. If the last statement has no assignment (it is missing `> ...`), then `> return` is implicit

// a `fn<(A a)R>` is a function that accepts argument `a` of type `A` and return value `R`. 
// a {...} block always evaluates to a `fn`, 
// a (A a){...} block evaluates to a `<(A a)R>` for some implied R, possibly void, 
// the type `fn<T>` is equal to `fn<()T>`
// the type `fn` is equal to `fn<()void>`
// whenever a `fn<T>` is assigned to a variable of `T`, it is evaluated
// a variable of type `T` may also be assigned to a variable of `fn<T>`, resulting in a function that just returns the value
// a {...} block may implicitly capture any variable in its scope
// captures are _always_ effectively copied
// nothing extends any `fn<(A a)R>`

// ---- the implicit universal pipedef file ---- 

type Result<T, E> = native

type boolean = Result<void, void> 
type int = native 
type float = native 
type String = native 
type LogicBuilder<T> = native

impl boolean {
    fn invert : boolean native // we do not define '!' because it looks weird in SCS
    fn if<T>(fn<T> true, fn<T> false) : T native
    fn ifTrue<T>(fn<T> then) : Result<T, void> native
    fn ifFalse<T>(fn<T> then) : Result<T, void> native
}

impl boolean[] {
    fn any: boolean native
    fn all: boolean native
}
impl int {
    fn isLessThan(int other): boolean native
    fn isLessOrEqualThan(int other): boolean native
    fn isGreaterThan(int other): boolean native
    fn isGreaterOrEqualThan(int other): boolean native
    fn equalTo(int other) : boolean native
    fn asFloat : float native
}
impl float {
    fn isLessThan(float other): boolean native
    fn isGreaterThan(float other): boolean native
}
impl String{
    fn equalTo(String other): boolean native
    fn is: LogicBuilder<String> native
}
// a lazy-evaluated boolean expression
impl LogicBuilder<T> {
    fn not: LogicBuilder<T> native
    fn equalTo(T other): boolean native
}

type Optional<T> = Result<T, void>

fn parallel(fn<T>[] executions) : T[] {
    // evaluating the array of functions as an array of T executes the functions
    executions
}

// ---- if generic type and impl were a thing, we could define these:

// any fn type
type<A, R> fn<(A a)R> = native
type<R> fn<R> = fn<()R>
type fn = fn<()void>

// any array
impl<T> T[] {
    fn any: LogicBuilder<T> native
    fn all: LogicBuilder<T> native
}

// each enum value is an object instance, the enum type is a type
impl<E : enum> E {
    /* every variant of the enum results in an argument of type T, with the name of the variant as argument name */
    fn switch<T>(T ... expression) : T native
    fn equalTo(E other): boolean native
}
