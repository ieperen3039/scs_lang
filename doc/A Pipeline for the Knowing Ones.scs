// Solid Command Sequence
// a prototype script language
// idea: simple and explicit
// the language does not have to be turing-complete, and will not use control structures if it does not use them

// Every function accepts either a specialisation of the type or a generalisation of the type.
// that is, you can implicitly cast up or down, but not both in one statement.
// Casting down (to a specialisation) may cause runtime errors, and should be avoided.
// Any non-static function of `T` can be applied to T[]. 
// This applies the function to each element in parallel, collecting the results as an array
// a closing bracket ends an expression. If the expression has no return (missing `> ...`), then `> return` is implicit

// a `fn<(A a)R>` is a function that accepts argument `a` of type `A` and return value `R`. 
// a {...} block always evaluates to a `fn`, 
// the type `fn<T>` is equal to `fn<()T>`
// the type `fn` is equal to `fn<()void>`
// whenever a fn<T> is assigned to a variable of T, it is evaluated
// a {...} block may implicitly capture any variable in its scope
// captures are _always_ effectively copied (before optimizations)
// nothing extends any `fn<(A a)R>`

// A `native` function describes a cdecl dll function

// ---- if generic type and impl were a thing, we could define these:

// any fn type
type<A, R> fn<(A a)R> = native
type<R> fn<R> = fn<()R>
type fn = fn<()void>

// any array
impl<T> T[] {
    fn any: LogicBuilder<T> native
    fn all: LogicBuilder<T> native
}

// each enum value is an object instance, the enum type is a type
impl<E : enum> E {
    /* every variant of the enum results in an argument of type T, with the name of the variant as argument name */
    fn switch<T>(T ... expression) : T native
    fn equalTo(E other): bool native
}

// ---- the implicit universal pipedef file ---- 

type bool = native {
    fn equalTo(bool other) : bool native
    fn invert : bool native // we do not define '!' because it looks weird in SCS
    fn switch<T>(T true, T false) : T native
    fn ifTrue<T>(T then) : Optional<T> native // see Optional<T>.orElse(T)
    fn ifFalse<T>(T then) : Optional<T> native // { this invert ifTrue(then) } // still works with orElse
}
type int = native {
    fn isLessThan(int other): bool native
    fn isLessOrEqualThan(int other): bool native
    fn isGreaterThan(int other): bool native
    fn isGreaterOrEqualThan(int other): bool native
    fn equalTo(int other) : bool native
    fn asFloat : float native
}
type float = native {
    fn isLessThan(float other): bool native
    fn isGreaterThan(float other): bool native
}
type String = native {
    fn equalTo(String other): bool native
    fn is: LogicBuilder<String> native
}
// a lazy-evaluated boolean expression
type LogicBuilder<T> = native {
    fn not: LogicBuilder<T> native
    fn equalTo(T other): bool native
}
// acts as `T` if it exists, otherwise functions are skipped
type Optional<T> = native {
    fn ifExists<R>(fn<(T)R> then) : Optional<R> native
    fn orPanic: T native
    fn orElse(T then): T native
    fn static None : Optional<T> native // returns the 'not' optional
}

fn static parallel(fn<()T>[] executions) : T[] native

// ---- an example for the system.scsdef file

fn getShellType : ShellType native
enum ShellType [
    Batch,
    Bash
]
fn getOS : OperatingSystem native
enum OperatingSystem [
    Windows,
    Unix,
    MacOS
]
// functions to run terminal commands
impl ShellType {
    // for enum member functions, the parameter `T ... a` evalutes to a series of parameters of type T, with the name of the variant as argument name.
    // inside the function, `a` will evaluate to the argument that corresponds to `this`, or when passed to another `T ... a`: expand to the original series of arguments.
    fn run(String ... command): int native
    fn readVariable(String variable_name) : String native
    
    fn call(String ... command) : ShellType {
        run(command) > errorCode; // discarded
        this > return; // this `> return` may be omitted, because the next token is a closing bracket
    }
}

// ---- an example for the std.scsdef file

use "system"

fs {
    type FilePath = String
    type AbsoluteFilePath = FilePath
    type RelativeFilePath = FilePath
}

fs {
    fn static directoryOfFile: AbsoluteFilePath {
        system.getShellType
            call(
                Batch: "set directoryOfThis=%cd%",
                Bash: "directoryOfThis=$PWD"
            )
            readVariable("directoryOfThis")
    }
    impl FilePath {
        fn append(RelativeFilePath): FilePath native
        
        fn copyTo(AbsoluteFilePath newPath): Optional<AbsoluteFilePath> {
            system.getShellType
                run(
                    Batch: "cp {this} {newPath}",
                    Bash: "cp {this} {newPath}"
                )
                equalTo(0)
                ifTrue(newPath)
                orElse(Optional.None)
        }
    }
    impl AbsoluteFilePath {
        fn getParent: AbsoluteFilePath native

        fn append(RelativeFilePath path): AbsoluteFilePath {
            this FilePath.append(path)
        }
    }
    impl RelativeFilePath {
        fn append(RelativeFilePath): RelativeFilePath {
            this FilePath.append(path)
        }
    }
}