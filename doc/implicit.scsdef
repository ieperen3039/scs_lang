
type void = native // zero-sized nothing-type

variant Result<P, N> {
    P pos,
    N neg,
}

type Optional<T> = Result<T, void>
type boolean = Result<void, void>

type int = native 
type float = native 
type String = native 

type fn<R> = fn<()R>
type fn = fn<()void>

impl boolean {
    fn if<T>(fn<T> true, fn<T> false) : T native
}

impl boolean[] {
    fn any: boolean native
    fn all: boolean native
}
impl int {
    fn isLessThan(int other): boolean native
    fn isLessOrEqualThan(int other): boolean native
    fn isGreaterThan(int other): boolean native
    fn isGreaterOrEqualThan(int other): boolean native
    fn equalTo(int other) : boolean native
    fn asFloat : float native
}
impl float {
    fn isLessThan(float other): boolean native
    fn isGreaterThan(float other): boolean native
}
impl String {
    fn equalTo(String other): boolean native
    fn is: LogicBuilder<String> native
}

impl Result<P, N> {
    fn invert : Result<N, P> { this on_pos ?* Result.neg !* Result.pos }
    fn unwrap_pos_or(P then) : P native
    fn unwrap_neg_or(N then) : N native

    fn on_pos<R>(fn<(P)R>) : Result<R, N> native
    fn on_neg<R>(fn<(N)R>) : Result<P, R> native

    op "?" : on_pos
    op "!" : on_neg 
}

// any array of results can be collapsed
impl Result<P, N>[] {
    fn any: Optional<P> native
    fn all: boolean native
    fn split : Result<P[], N[]> native
}

impl <T> {
    fn equalTo<T>(T other) : boolean native

    fn _apply_on_fn<R>(fn<(T)R> mapping) : R { mapping(this) }
    fn _replace_with<R>(R new_value) : R { new_value }
     // creates a new name in the scope
    fn _assign_to_variable(...) : void native

    op "=" : _assign_to_variable
    op "*" : _apply_on_fn 
    op ";" : _replace_with
}

impl <T>[] {
    // partition does not change the size of the array.
    // you'll have to use a 'positive-assign' to get the array of positive values.
    fn partition(fn<(T)boolean> predicate) : Result<T, T> native
    fn collect(fn<(T, T)T> collector) : T native
    fn collect<Acc>(Acc accumulator, fn<(Acc, T)Acc> collector) : Acc native
    fn map<R>(fn<(T)R> mapping) : R[] native
    // combines every two adjacent elements into a new element (resutling in an array of 1 less length)
    fn multimap<R>(fn<(T, T)R> mapping) : T[] native
    fn first : Optional<T> native
    fn append(T new_element) : T[] native

    fn filter(fn<(T)boolean> predicate) : T[] { this > partition(predicate) split }
    fn append(T[] other) : T[] { other collect(this, append) }

    op "*" : first
    op ">" : map
    op "+" : append
}

//  the enum type is a type, each enum value is an object instance
impl enum {
    /* every element of the enum expands to an argument of type T, with the name of the element as argument name */
    fn switch<T>(T ... expression) : T native
    fn equalTo(enum other): boolean native
}

// both the variant type and the variant elements are types
// the variant elements are separately instantiable and name-able
impl variant<E...> {
    /* every element of the variant expands to an argument of type T, with the name of the element as argument name */
    fn switch<T>(T ... expression) : T native
    fn as(E expected): Optional<E> native
}

impl variant<E...>[] {
    fn split : (E[]...)[] native
}

impl fn<(P)R> {
    fn _chain<R2>(fn<(R)R2> next_function) : fn<(P)R2> native
    // { 
    //     (input) { 
    //         input * this * next_function
    //     } 
    // }

    op "+" : _chain
} 