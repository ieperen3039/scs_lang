
type void = native // zero-sized nothing-type

variant Result<P, N> {
    Pos(P),
    Neg(N),
}

type Maybe<T> = Result<T, void>
type boolean = Result<void, void> // = Maybe<void>

type int = native 
type float = native 
type String = native 

type fn<R> = fn<()R>

impl boolean {
    fn if<T>(fn<T> true, fn<T> false) : T native
}
impl int {
    fn isLessThan(int other): boolean native
    fn isLessOrEqualThan(int other): boolean native
    fn isGreaterThan(int other): boolean native
    fn isGreaterOrEqualThan(int other): boolean native
    fn equalTo(int other) : boolean native
    fn asFloat : float native
}
impl float {
    fn isLessThan(float other): boolean native
    fn isGreaterThan(float other): boolean native
}
impl String {
    fn equalTo(String other): boolean native
    fn is: LogicBuilder<String> native
}

impl Result<P, N> {
    fn invert : Result<N, P> { 
        this switch(Pos: Result.Neg, Neg: Result.Pos)
    }

    fn unwrap_pos_or(N default) : P switch(Pos: identity, Neg: default)
    fn unwrap_neg_or(P default) : N switch(Pos: default, Neg: identity)
    
    fn map_both(fn<(P)R> pos, fn<(N)R> neg)
    {
        this ? pos ! neg = return; 
    }

    fn on_pos<R>(fn<(P)R> mapping) : Result<R, N> map_both(pos: mapping, neg: identity)
    fn on_neg<R>(fn<(N)R> mapping) : Result<P, R> map_both(pos: identity, neg: mapping)

    op "?" : on_pos
    op "!" : on_neg 
}

// any array of results can be collapsed
impl Result<P, N>[] {
    fn any: Maybe<P> native
    fn all: boolean native
    fn filter_pos: P[] native
    fn filter_neg: N[] native
}

impl Maybe<T>[] {
    fn filter: T[] { this filter_pos }
}

impl<T> T {
    fn identity : T { this }
    fn equalTo<T>(T other) : boolean native

    fn _apply_on_fn<R>(fn<(T)R> mapping) : R { mapping(this) }
    fn _replace_with<R>(R new_value) : R { new_value }
     // creates a new name in the scope
    fn _assign_to_variable(...) : void native

    op "=" : _assign_to_variable
    op ":" : _replace_with
}

impl<T> T[] {
    fn collect(fn<(T, T)T> collector) : T native
    fn collect<Acc>(Acc accumulator, fn<(Acc, T)Acc> collector) : Acc native
    fn map<R>(fn<(T)R> mapping) : R[] native
    // combines every two adjacent elements into a new element (resutling in an array of 1 less length)
    fn multimap<R>(fn<(T, T)R> mapping) : T[] native
    fn first : Maybe<T> native
    fn append(T new_element) : T[] native

    // partition does not change the size of the array.
    fn partition(fn<(T)boolean> predicate) : Result<T, T>[] {
        this > (elt) { 
            predicate(elt) !: elt ?: elt 
        }
    }


    fn filter(fn<(T)boolean> predicate) : T[] { 
        this > (elt) { 
            elt predicate ?: elt 
        }
        filter_pos
    }

    fn append(T[] other) : T[] { other collect(this, append) }

    op "*" : first
    op ">" : map
    op "+" : append
}

//  the enum type is a type, each enum value is an object instance
impl enum {
    /* every element of the enum expands to an argument of type T, with the name of the element as argument name */
    fn switch<T>(T ... expression) : T native
    fn equalTo(enum other): boolean native
}

// both the variant type and the variant elements are types
// the variant elements are separately instantiable and name-able
impl variant<E...> {
    /* every element of the variant expands to an argument of type T, with the name of the element as argument name */
    fn switch<T>(fn<(E)T> ... expression) : T native
    fn as(E expected): Maybe<E> native
}

impl variant<E...>[] {
    fn split : (E[]...)[] native
}