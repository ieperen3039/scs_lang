scs_program             = [ _shebang ], _, [ version_declaration ], { _, ( _definition | include_declaration | alias_declaration ) }, [ _, _lamda ] ;

version_declaration     = _keyword_version, _, version_dialect, _, [ version ];
version_dialect         = _name;
version                 = version_major, ".", version_minor, ".", version_patch;
version_major           = _integer_literal;
version_minor           = _integer_literal;
version_patch           = _integer_literal;

include_declaration     = _keyword_use, _, _string_literal;
alias_declaration       = _keyword_use, _, identifier, _, "=", _, identifier;

_definition              = scope | type_definition | enum_definition | variant_definition | implementation | function_definition;
scope                   = identifier, _, "{", { _, _definition }, _, "}";

type_definition         = _keyword_type, _, "=", _, ( type_name | _keyword_native ), _, [ "{", { _, function_definition }, _, "}" ];
type_name               = _base_type | array_type | fn_type;
_base_type              = identifier, _, [ generic_type ];
generic_type            = "<", _, identifier, _, ">";
array_type              = (_base_type | fn_type ), "[", _, "]";
fn_type                 = _keyword_fn, _, [ "<", _, [ "(", { _, unnamed_parameter_list }, _, ")", _ ], type_name, ">" ];
unnamed_parameter_list  = type_name, { _, ",", _, type_name };
enum_definition         = _keyword_enum, _, identifier, _, "[", _, { _, identifier, _, "," }, _, "]";
variant_definition      = _keyword_variant, _, identifier, _, "[", _, { _, identifier, _, "," }, _, "]";
implementation          = _keyword_start_implementation, _, type_name, _, "{", { _, function_definition }, _, "}";

function_definition     = function_signature, _, ( function_block | _keyword_native, _ );
function_signature      = _keyword_fn, _, [ _keyword_static, _ ], identifier, _, [ generic_type ], _, [ "(", _, [ parameter_list ], _, ")", _ ], ":", _, type_name;
parameter_list          = parameter, { _, ",", _, parameter };
parameter               = type_name, _, [ "...", _ ], identifier;
function_block          = "{", { _, statement }, [ _, last_statement ], _, "}";
(* it is a syntax error, but not a parse error, to not end with an all-assign *)
statement               = _expression, { _, _mutator }, _, ";"; 
_mutator                = mutator_method | mutator_application | mutator_stop_new | mutator_assign;
mutator_method          = _selector_symbol, usage_method, _, function_call_tail;
mutator_application     = _selector_symbol, usage_application, _, static_function_call;
mutator_stop_new        = _selector_symbol, usage_stop_new, _, _expression;
mutator_assign          = _selector_symbol, usage_assign, _, ( _keyword_return | [ type_name ], _, identifier);
last_statement          = _expression, _, { function_call_tail };
_expression             = identifier | static_function_call | function_block | array_initialisation | _literal;
static_function_call    = identifier, _, ".", function_call_tail;
function_call_tail      = identifier, _, [ "(", [ _, argument_list ], _, ")" ];
argument_list           = _expression, _ | named_argument, { _, ",", _, named_argument };
named_argument          = identifier, _, ":", _, _expression;
array_initialisation    = "[", [ _, _expression, { _, ",", _, _expression } ], _, "]";

_selector_symbol         = selector_both | selector_positive | selector_negative;
_usage_symbol            = usage_method | usage_application | usage_stop_new | usage_assign;
_lamda                  = "(", _, parameter_list, _, ")", _, function_block;
_literal                = string_literal | integer_literal | decimal_literal | hexadecimal_literal | binary_literal;

identifier              = _name;
integer_literal         = _integer_literal;
decimal_literal         = _decimal_literal;
string_literal          = _string_literal;

selector_both = ":";
selector_positive = ">";
selector_negative = "?";
usage_method = ">";
usage_application = "?";
usage_stop_new = "!";
usage_assign = "=";

_keyword_version = "version";
_keyword_type = "type";
_keyword_fn = "fn";
_keyword_enum = "enum";
_keyword_variant = "variant";
_keyword_native = "native";
_keyword_this = "this";
_keyword_return = "return";
_keyword_static = "static";
_keyword_use = "use";
_keyword_start_implementation = "impl";

_name = "/[a-zA-Z_][a-zA-Z0-9_]*/";
_string_literal = '/"(.*?[^\\]|)"/';
_integer_literal = "/\d+/";
_decimal_literal = "/0-9[0-9_]*.[0-9]*/";
hexadecimal_literal = "/0x[0-9A-F_]+/";
binary_literal = "/0b[01_]+*/";

_shebang = "/#!.*/";

_ = { _line_comments | _block_comments | _whitespace };
_whitespace = "/[\s\n]+/";
_line_comments = "/\/\/.*/";
_block_comments = "/\/\*.*\*\//";