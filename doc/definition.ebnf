(*
After every token, we match with, and ignore, the following regex's:
whitespace : /[\s\n]+/
line comments: /\/\/.*/
block comments: /\/\*.*\*\// 
*)

scs_program             = [ version_declaration ], { definition | use_declaration }, function_block;

version_declaration     = KeywordVersion, Name, ( Star | version );
version                 = IntegerLiteral, Period, IntegerLiteral, Period, IntegerLiteral;

use_declaration         = KeywordUse, StringLiteral;

definition              = scope | type_definition | enum_definition | implementation | function_definition;
scope                   = Name, BracketOpen, { definition }, BracketClose;

type_definition         = KeywordType, Equal, ( type_name | KeywordNative ), [ BracketOpen, { function_definition }, BracketClose ];
type_name               = named_type | array_type | fn_type;
named_type              = Name, [ generic_type ];
generic_type            = AngleBracketOpen, Name, AngleBracketClose;
array_type              = type_name, SquareBracketOpen, SquareBracketClose;
fn_type                 = KeywordFn, [ AngleBracketOpen, [ ParenthesisOpen, { unnamed_parameter_list }, ParenthesisClose ], type_name, AngleBracketClose ];
unnamed_parameter_list  = type_name, { Comma, type_name };
enum_definition         = KeywordEnum, Name, SquareBracketOpen, { Name, Comma }, SquareBracketClose;

implementation          = KeywordImpl, type_name, BracketOpen, { function_definition }, BracketClose;

function_definition     = function_signature, ( function_block | KeywordNative );
function_signature      = KeywordFn, [ KeywordStatic ], Name, [ generic_type ], [ ParenthesisOpen, [ parameter_list ], ParenthesisClose ], Colon, type_name;
parameter_list          = parameter, { Comma, parameter };
parameter               = type_name, [ Ellipsis ], Name;
function_block          = BracketOpen, { statement }, [ last_statement ], BracketClose;
statement               = expression, { method_call }, [ assignment ], SemiColon;
last_statement          = expression, { method_call };
expression              = Name | static_function_call | function_block | array_initialisation | literal;
static_function_call    = Name, Period, method_call;
method_call             = Name, [ ParenthesisOpen, [ argument_list ], ParenthesisClose ];
argument_list           = Name | named_argument, { Comma, named_argument };
named_argument          = Name, Colon, expression;
array_initialisation    = SquareBracketOpen, [ expression, { Comma, expression } ], SquareBracketClose;
literal                 = StringLiteral | IntegerLiteral | DecimalLiteral | HexadecimalLiteral | BinaryLiteral;
assignment              = AngleBracketClose, ( KeywordReturn | [ type_name ], Name);

Comma = ",";
Colon = ":";
SemiColon = ";";
ParenthesisOpen = "(";
ParenthesisClose = ")";
BracketOpen = "{";
BracketClose = "}";
SquareBracketOpen = "[";
SquareBracketClose = "]";
AngleBracketOpen = "<";
AngleBracketClose = ">";
Ellipsis = "...";
Period = ".";
Equal = "=";
Star = "*";
KeywordType = "type";
KeywordFn = "fn";
KeywordEnum = "enum";
KeywordNative = "native";
KeywordThis = "this";
KeywordVoid = "void";
KeywordReturn = "return";
KeywordStatic = "static";
KeywordUse = "use";
KeywordImpl = "impl";
KeywordVersion = "version";
Name = ? regex ?(* /[a-zA-Z_][a-zA-Z0-9_]*/ *);
StringLiteral = ? regex ?(* /"(.*?[^\\]|)\"/ *);
IntegerLiteral = ? regex ?(* /\d*/ *);
DecimalLiteral = ? regex ?(* /0-9[0-9_]*.[0-9]*/ *);
HexadecimalLiteral = ? regex ?(* /0x[0-9A-F_]+/ *);
BinaryLiteral = ? regex ?(* /0b[01_]+*/ *);