scs_program             = [ _shebang ], _, [ version_declaration, _ ], { ( _definition | include_declaration ), _ }, [ function_interface, _, function_block ], _;

(* version *)
version_declaration     = _keyword_version, _, version_dialect, [ _, version ];
version_dialect         = _name;
version                 = version_major, ".", version_minor, ".", version_patch;
version_major           = _integer_number;
version_minor           = _integer_number;
version_patch           = _integer_number;

(* include section *)
include_declaration     = _keyword_use, _, '"', include_file, '"';
include_file            =  { directory, "/" }, file;
directory               = _file_name;
file                    = _file_name;

(* scopes and definitions *)
_definition             = scope | type_definition | enum_definition | implementation | function_definition;
scope_name              = identifier;
scope                   = scope_name, _, "{", { _definition, _ }, _, "}";
_scope_call             = { scope_name, _, "." };
type_definition         = _keyword_type, _, base_type, _, [ ( ":", _, type_name, _ ) | ( native_decl, _ ) ], ["[", _, { function_definition, _ }, "]" ];
type_name               = _type_name;
_type_name              = _scope_call, ( base_type | array_type | fn_type );
base_type               = identifier, _, [ generic_types ];
generic_types           = "<", _, _type_list, _, ">";
array_type              = (base_type | fn_type ), "[", _, "]";
fn_type                 = _keyword_fn, _, [ "<", _, [ "(", _, { unnamed_parameter_list, _ }, ")", _ ], return_type, _, ">" ];
enum_definition         = _keyword_enum, _, identifier, _, "[", _, { identifier, _, ",", _ }, "]";
implementation          = _keyword_start_implementation, _, type_name, _, "{", _, { function_definition, _ }, "}";

(* function definitions and parameters *)
function_definition     = function_signature, _, ( function_block | native_decl );
function_signature      = _keyword_fn, _, function_name, _, [ generic_types, _ ], function_interface;
function_name           = _name;
function_interface      = "(", _, [ parameter_list, _ ], ")", _, ":", _, return_type;
parameter_list          = parameter, { _, ",", _, parameter };
parameter               = type_name, _, [ expansion_decl, _ ], identifier;
unnamed_parameter_list  = _type_list;
untyped_parameter_list  = _name_list;
return_type             = _type_name;

(* statements *)
(* it is a syntax error, but not a parse error, to not end with an all-assign *)
function_block          = "{", _, statement, _, { ";", _, [ statement, _ ] }, "}";
statement               = _expression, { _, _mutator }; 
_expression             = identifier | static_function_call | lambda | array_initialisation | _literal;

(* function call statements *)
static_function_call    = _scope_call, _function_call_tail;
method_call             = _function_call_tail;
_function_call_tail     = function_name, _, [ "(", [ _, _argument_list ], _, ")" ];
_argument_list          = single_argument | ( named_argument, { _, ",", _, named_argument } );
single_argument         = _expression;
named_argument          = identifier, _, ":", _, _expression;
_type_list              = type_name, { _, ",", _, type_name };
_name_list              = identifier, { _, ",", _, identifier };
_static_callable        = ( _scope_call, identifier ) | lambda;

(* mutators, selectors and usage indicators *)
_selector_symbol        = selector_both | selector_positive | selector_negative;
_usage_symbol           = usage_method | usage_application | usage_stop_new | usage_assign;

_mutator                = _mutator_method | _mutator_application | _mutator_stop_new | _mutator_assign | implicit_method;
_mutator_method         = _selector_symbol, usage_method, _, method_call;
_mutator_application    = _selector_symbol, usage_application, _, _static_callable;
_mutator_stop_new       = _selector_symbol, usage_stop_new, _, _expression;
_mutator_cast           = _selector_symbol, usage_cast, _, type_name, _, _cast_end;
_mutator_assign         = _selector_symbol, usage_assign, _, ( return_decl | [ type_name ], _, identifier);
implicit_method         = method_call;

(* other statements *)
array_initialisation    = "[", [ _, _expression, { _, ",", _, _expression } ], _, "]";
lambda                  = _lamda;
_lamda                  = [ "(", _, untyped_parameter_list, _, ")", _ ], [ ":", _, return_type ], _, function_block;
_literal                = string_literal | integer_literal;

(* keyword wrappers *)
return_decl             = _keyword_return;
native_decl             = _keyword_native;

(* other wrappers *)
identifier = _name;
string_literal = _string_literal;
integer_literal = _integer_number;
floating_point_literal = _floating_point_number;

(* symbol definitions *)
selector_both = ":";
selector_positive = ">";
selector_negative = "?";

usage_method = ">";
usage_application = "?";
usage_stop_new = "!";
usage_assign = "=";
usage_cast = ":<";
_cast_end = ">";

expansion_decl = "...";

(* keywords *)
_keyword_version = "version";
_keyword_type = "type";
_keyword_fn = "fn";
_keyword_enum = "enum";
_keyword_variant = "variant";
_keyword_native = "native";
_keyword_this = "this";
_keyword_return = "return";
(* _keyword_static = "static"; *)
_keyword_use = "use";
_keyword_start_implementation = "impl";

(* regex matchers *)
_name = "/[\w][\w0-9]*/";
_string_literal = '/"(.*?[^\\]|)"/';
_integer_number = "/\d+/";
_floating_point_number = "/0-9[0-9_]*.[0-9]*/";
(* _hexadecimal_number = "/0x[0-9A-F_]+/"; *)
(* _binary_number = "/0b[01_]+*/"; *)
_file_name = '/[^\\\/"\n]+/';
_shebang = "/#!.*/";

(* whitespace *)
_ = { _line_comments | _block_comments | _whitespace };
_whitespace = "/[\s\r\n]+/";
_line_comments = "/\/\/.*/", _whitespace;
_block_comments = "/\/\*.*?\*\//";