faux_program            = [ version_declaration ], { include_declaration }, { _definition }, [ program_interface, function_block ];
program_interface       = _function_interface;

(* version *)
version_dialect         = "faux";
version_declaration     = _keyword_version, version_dialect, [ version ];
version                 = version_major, ".", version_minor, ".", version_patch;
version_major           = ? NUMBER ?;
version_minor           = ? NUMBER ?;
version_patch           = ? NUMBER ?;

(* include section *)
include_declaration     = _keyword_use, include_file;
include_file            = ? STRING ?;

(* scopes and definitions *)
identifier              = ? IDENTIFIER ?;
_definition             = constant_def | scope | type_definition | enum_definition | variant_definition | implementation | function_definition;
scope                   = scope_name, "{", { _definition }, "}";
scope_name              = ? IDENTIFIER ?;
(* types cannot derive from fn_type or from buffers, but that is not a parser error *)
type_definition         = _keyword_type, base_type_decl, "=",  ( type_ref | native_decl );
field_declaration       = type_ref, identifier, ";";
(* reference to existing type *)
type_ref                = ( ( { scope_name, "." }, base_type_ref ) | tuple_inst | fn_type ), { buffer_symbol };
(* instantiation of a tuple *)
tuple_inst               = "[", _type_list, "]";
(* reference to existing base type, enum or variant. instantiates generic types *)
base_type_ref           = identifier, [ generic_types_inst ];
(* declaration of new type name, declares the existence of generic types *)
base_type_decl          = identifier, [ generic_types_decl ];
(* declaration of generic types *)
generic_types_decl      = "<", _name_list, ">";
(* instantion of generic types *)
generic_types_inst      = "<", _type_list, ">";
(* function does not actually use a generic_types_decl, only syntactically *)
fn_type                 = _keyword_fn, "<", [ "(", unnamed_parameter_list, ")" ], return_type, ">";
enum_definition         = _keyword_enum, identifier, "[", enum_value_decl, { ",", enum_value_decl }, "]";
enum_value_decl         = ? IDENTIFIER ?;
variant_definition      = _keyword_variant, identifier, [ generic_types_decl ], "[", variant_value_decl, { ",", variant_value_decl }, "]";
variant_value_decl      = identifier, "(", type_ref, ")";
(* generics are not instantiated, hence a base_type_decl *)
implementation          = _keyword_start_implementation, base_type_decl, { buffer_symbol }, "{", { function_definition }, "}";

constant_def            = _keyword_const, type_ref, identifier, "=", statement;

(* function definitions and parameters *)
function_definition     = function_signature, ( function_block | native_decl );
function_signature      = _keyword_fn, function_name, [ generic_types_decl ], _function_interface;
function_name           = ? IDENTIFIER ?;
_function_interface      = "(", [ parameter_list ], ")", ":", return_type;
parameter_list          = parameter, { ",", parameter };
parameter               = type_ref, [ expansion_decl ], identifier;
unnamed_parameter_list  = _type_list;
untyped_parameter_list  = _name_list;
return_type             = type_ref | "!";

(* statements *)
function_block          = "{", statement, { statement_separator, statement }, [ statement_separator ], "}";
statement               = _value_expression, { ',', { operator }, _mutator }; 
variable_name           = ? IDENTIFIER ?;
_value_expression       = variable_name | static_function_call | tuple_construction | _literal; 
statement_separator     = ";";
_expression             = _value_expression | lambda | method_reference;

(* function call statements *)
static_function_call    = { scope_name, "." }, function_name, "(", [ _argument_list ], ")";
method_call             = function_name, [ "(", [ _argument_list ], ")" ];
method_reference        = type_ref, ".", method_call;
_argument_list          = single_argument | ( named_argument, { ",", named_argument } );
single_argument         = _expression;
named_argument          = identifier, ":", _expression;
_type_list              = type_ref, { ",", type_ref };
_name_list              = identifier, { ",", identifier };

(* mutators, selectors and usage indicators *)
_mutator                = method_call | static_function_call | mutator_cast | mutator_assign;
operator                = ? OPERATOR ?;
mutator_cast            = _usage_cast, type_ref;
mutator_assign          = _usage_assign, ( return_decl | ( [ type_ref ], variable_name) );

(* other statements *)
(* buffer_construction     = "[", [ _expression, { ",", _expression } ], "]"; *)
tuple_construction      = "[", [ _expression, { ",", _expression } ], "]";
(* implicit parameter lamdas are potentially indistinguishable from zero-parameter lamdas *)
(* However the first statement of a implicit parameter lamdas may be a mutator *)
lambda                  = [ "(", untyped_parameter_list, ")", [ ":", return_type ] ], function_block;
_literal                = string_literal | integer_literal | float_literal;
string_literal          = ? STRING ?;
integer_literal         = ? NUMBER ?;
float_literal           = ? NUMBER ?, ".", ? NUMBER ?;

(* wrappers *)
return_decl             = _keyword_return;
native_decl             = _keyword_extern;

(* symbol definitions *)
_usage_assign = "=";
_usage_cast = "as";
buffer_symbol = "[]";
expansion_decl = "...";

(* keywords *)
_keyword_version = "version";
_keyword_type = "type";
_keyword_fn = "fn";
_keyword_enum = "enum";
_keyword_variant = "variant";
_keyword_extern = "extern";
_keyword_const = "const";
_keyword_this = "this";
_keyword_return = "return";
(* _keyword_static = "static"; *)
_keyword_use = "use";
_keyword_start_implementation = "impl";