_                              = [ ? WHITESPACE ? ];
_argument_list                 = ( single_argument | ( named_argument, { ( _, ",", _, named_argument ) } ) );
_cast_end                      = ">";
_definition                    = ( constant_def | scope | type_definition | enum_definition | variant_definition | implementation | function_definition );
_expression                    = ( identifier | static_function_call | lambda | array_initialisation | _literal );
_function_call_tail            = ( function_name, _, [ ( "(", [ ( _, _argument_list ) ], _, ")" ) ] );
_function_interface            = ( "(", _, [ ( parameter_list, _ ) ], ")", _, ":", _, return_type );
_keyword_const                 = "const";
_keyword_enum                  = "enum";
_keyword_extern                = "extern";
_keyword_fn                    = "fn";
_keyword_return                = "return";
_keyword_start_implementation  = "impl";
_keyword_this                  = "this";
_keyword_type                  = "type";
_keyword_use                   = "use";
_keyword_variant               = "variant";
_keyword_version               = "version";
_lamda                         = ( [ ( "(", _, untyped_parameter_list, _, ")", _ ) ], [ ( ":", _, return_type ) ], _, function_block );
_literal                       = ( string_literal | integer_literal | float_literal );
_mutator                       = ( method_call | static_function_call | operator );
_mutator_assign                = ( usage_assign, _, ( return_decl | ( [ type_ref ], _, identifier ) ) );
_mutator_cast                  = ( usage_cast, _, type_ref, _, _cast_end );
_name_list                     = ( identifier, { ( _, ",", _, identifier ) } );
_scope_reference               = ( scope_name, { ( ".", scope_name ) } );
_type_list                     = ( type_ref, { ( _, ",", _, type_ref ) } );
array_initialisation           = ( "[", [ ( _, _expression, { ( _, ",", _, _expression ) } ) ], _, "]" );
array_symbol                   = "[]";
base_type_decl                 = ( identifier, [ ( _, generic_types_decl ) ] );
base_type_ref                  = ( identifier, [ ( _, generic_types_inst ) ] );
constant_def                   = ( _keyword_const, _, type_ref, _, identifier, _, "=", _, statement );
derived_type                   = ( ( [ ( _scope_reference, "." ) ], base_type_ref ) | tuple_inst );
enum_definition                = ( _keyword_enum, _, identifier, _, "[", _, enum_value_decl, _, { ( ",", _, enum_value_decl, _ ) }, "]" );
enum_value_decl                = ? IDENTIFIER ?;
expansion_decl                 = "...";
faux_program                   = ( _, [ ( version_declaration, _ ) ], { ( include_declaration, _ ) }, { ( _definition, _ ) }, [ ( program_interface, _, function_block ) 
], _ );
field_declaration              = ( type_ref, _, identifier, _, ";" );
float_literal                  = ( ? NUMBER ?, ".", ? NUMBER ? );
fn_type                        = ( _keyword_fn, _, [ ( "<", _, [ ( "(", _, unnamed_parameter_list, _, ")", _ ) ], return_type, _, ">" ) ] );
function_block                 = ( "{", _, statement, _, { ( statement_separator, _, [ ( statement, _ ) ] ) }, "}" );
function_definition            = ( function_signature, _, ( function_block | native_decl ) );
function_name                  = ? IDENTIFIER ?;
function_signature             = ( _keyword_fn, _, function_name, _, [ ( generic_types_decl, _ ) ], _function_interface );
generic_types_decl             = ( "<", _, _name_list, _, ">" );
generic_types_inst             = ( "<", _, _type_list, _, ">" );
identifier                     = ? IDENTIFIER ?;
implementation                 = ( _keyword_start_implementation, _, base_type_decl, { ( _, array_symbol ) }, _, "{", _, { ( function_definition, _ ) }, "}" );
include_declaration            = ( _keyword_use, _, include_file );
include_file                   = ? STRING ?;
integer_literal                = ? NUMBER ?;
lambda                         = _lamda;
method_call                    = ( [ ( type_ref, "." ) ], _function_call_tail );
named_argument                 = ( identifier, _, ":", _, _expression );
native_decl                    = _keyword_extern;
operator                       = ? SYMBOL ?;
parameter                      = ( type_ref, _, [ ( expansion_decl, _ ) ], identifier );
parameter_list                 = ( parameter, { ( _, ",", _, parameter ) } );
program_interface              = _function_interface;
return_decl                    = _keyword_return;
return_type                    = type_ref;
scope                          = ( scope_name, _, "{", _, { ( _definition, _ ) }, "}" );
scope_name                     = ? IDENTIFIER ?;
single_argument                = _expression;
statement                      = ( _expression, { ( _, _mutator ) } );
statement_separator            = ";";
static_function_call           = ( [ _scope_reference ], _function_call_tail );
string_literal                 = ? STRING ?;
tuple_inst                     = ( "[", _, _type_list, _, "]" );
type_definition                = ( _keyword_type, _, base_type_decl, _, "=", ( derived_type | native_decl ) );
type_ref                       = ( ( ( [ ( _scope_reference, "." ) ], base_type_ref ) | fn_type | tuple_inst ), { ( _, array_symbol ) } );
unnamed_parameter_list         = _type_list;
untyped_parameter_list         = _name_list;
usage_assign                   = "=";
usage_cast                     = ":<";
variant_definition             = ( _keyword_variant, _, identifier, _, [ ( generic_types_decl, _ ) ], "[", _, variant_value_decl, _, { ( ",", variant_value_decl, _ ) }, 
"]" );
variant_value_decl             = ( identifier, _, "(", _, type_ref, _, ")" );
version                        = ( version_major, ".", version_minor, ".", version_patch );
version_declaration            = ( _keyword_version, _, version_dialect, [ ( _, version ) ] );
version_dialect                = ? IDENTIFIER ?;
version_major                  = ? NUMBER ?;
version_minor                  = ? NUMBER ?;
version_patch                  = ? NUMBER ?;